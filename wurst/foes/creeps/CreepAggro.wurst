package CreepAggro
import DamageEvent
import GameConstants
import HashMap
import LinkedList
import UnitIndexer
import Orders
import PlayerData
import GameTimer
import Abilities
import AttachmentPoints
import ClosureTimers
import BonusHandler

class AggroEntry
    unit source
    var aggro = 0.

    construct(unit source, real aggro)
        this.source = source
        this.aggro = aggro

constant aggroMap = new HashMap<unit, LinkedList<AggroEntry>>()
constant lastAttackOrder = new HashMap<unit, real>
constant lastSuccessfulAttack = new HashMap<unit, real>

public function unit.clearAggro()
    let aggroList = aggroMap.get(this)
    lastAttackOrder.remove(this)
    if aggroList != null
        for aggro in aggroList
            destroy aggro
        aggroList.clear()

public function unit.enrage()
    this.setVertexColor(225, 125, 125, 225)
    this.setMoveSpeed(this.getMoveSpeed() + 75)
    this.addBonus(Bonus.ATTACKSPEED, 25)

    let eff = this.addEffect(Abilities.bloodLustTarget, AttachmentPoints.chest)

    doAfter(1.) ->
        eff.destr()

public function unit.addAggro(unit target, real amount)
    let source = this
    if not aggroMap.has(target)
        aggroMap.put(target, new LinkedList<AggroEntry>())

    if source != null
        let aggroList = aggroMap.get(target)
        let first = aggroList.getFirst()
        var found = false
        for aggro in aggroList
            if aggro.source == source
                aggro.aggro += amount
                found = true
            else
                aggro.aggro *= 0.9

        if not found
            aggroList.add(new AggroEntry(source, amount))

        aggroList.sortWith((a, b) -> (b.aggro - a.aggro).toInt())
        
        let lastAttack = lastAttackOrder.get(target)
        if first != aggroList.getFirst() and not lastAttackOrder.has(target) or lastAttack < currentTime - 3
            target.issueTargetOrderById(OrderIds.attack, source)
            lastAttackOrder.put(target, currentTime)

init
    DamageEvent.addListener() ->
        var source = DamageEvent.getSource()
        let target = DamageEvent.getTarget()
        let sourceOwner = source.getOwner()
        let targetOwner = target.getOwner()

        if targetOwner == ENEMY_PLAYER and sourceOwner.isHuman() and not target.isType(UNIT_TYPE_PEON)
            if source.hasAbility(LOCUST_ID)
                let pdata = pData.get(sourceOwner)
                if pdata != null
                    source = pdata.getHero().hero.actor

            source.addAggro(target, DamageEvent.getAmount())

            let lastAttack = lastSuccessfulAttack.get(target)
            if lastAttack + 30 < currentTime
                target.enrage()
        
        else if sourceOwner == ENEMY_PLAYER
            lastSuccessfulAttack.put(source, currentTime)
                
    
    onUnitIndex() ->
        lastSuccessfulAttack.put(getIndexingUnit(), currentTime)
        
    onUnitDeindex() ->
        let u = getIndexingUnit()
        lastAttackOrder.remove(u)
        lastSuccessfulAttack.remove(u)
        let aggro = aggroMap.getAndRemove(u)
        if aggro != null
            for agg in aggro
                destroy agg
            destroy aggro
