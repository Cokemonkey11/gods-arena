package Wave
import public ClosureTimers
import public LinkedList
import PlayerData
import Creep
import CreepObjEditing
import ObjectIdGenerator
import SoundUtils
import GameProperties
import Abilities
import Funcs

constant AFTER_WAVE_RESTORATION_SOUND = new SoundDefinition(Sounds.restorationPotion)

interface NextStepListener
  abstract function execute()

abstract class WaveStep
  Wave wave

  construct (Wave wave)
    this.wave = wave

  abstract function execute(NextStepListener next)

class WaitStep extends WaveStep
  var duration = 0.
 

  construct(Wave wave, real duration)
    super(wave)
    this.duration = duration

  override function execute(NextStepListener next)
    doAfter(duration) -> 
      next.execute()


class CreepStep extends WaveStep
  let unitId = UNIT_ID_GEN.next()
  CreepDefinition creepDef

  var amount = 1

  construct(Wave wave, int origUnitId)
    super(wave)
    creepDef = new CreepDefinition(unitId, origUnitId)

  override function execute(NextStepListener next)
    doPeriodicallyCounted(0.05, amount) cb ->
      new Creep(unitId, wave.spawnPoint.execute().toVec3(), GetRandomReal(0, 360).fromDeg())
      if cb.isLast()
        next.execute()
      

public class WaveBuilder
  let result = new Wave()
  let steps = new LinkedList<WaveStep>
  var currentUnitId = '0000'
  WaveStep currentStep = null
  CreepStep creepStep = null

  function wait(real duration)
    if currentStep != null
      steps.add(currentStep)
      currentStep = null

      steps.add(new WaitStep(result, duration))

  function creep(int origUnitId)
    if currentStep != null
      steps.add(currentStep)
      currentStep = null

    creepStep = new CreepStep(result, origUnitId)
    currentStep = creepStep

  function abilities(string abilities)
    creepStep.creepDef.setNormalAbilities(abilities)

  function amount(int amount)
    creepStep.amount = amount

  function hp(int hp)
    creepStep.creepDef.setHitPointsMaximumBase(hp)

  function damage(int dmg)
    creepStep.creepDef.setAttack1DamageBase(dmg)

  function armor(int armor)
    creepStep.creepDef.setDefenseBase(armor)

  function model(string path)
    creepStep.creepDef.setModelFile(path)

  function scale(real scale)
    creepStep.creepDef.setScalingValue(scale)

  function rgb(int red, int green, int blue)
    creepStep.creepDef.setTintingColorRed(red)
    creepStep.creepDef.setTintingColorGreen(green)
    creepStep.creepDef.setTintingColorBlue(blue)

  function goldBounty(int bounty)
    this.result.goldBounty = bounty
    
  function expBounty(int bounty)
    this.result.expBounty = bounty

  function build() returns Wave
    if currentStep != null
      steps.add(currentStep)
      currentStep = null
    result.steps = steps
    return result

constant NEXT_WAVE = new SoundDefinition(Sounds.questNew)
constant WAVE_FINISHED = new SoundDefinition(Sounds.questCompleted)

public class Wave
  LinkedList<WaveStep> steps
  Vec2Function spawnPoint
  
  var goldBounty = 100
  var expBounty = 100

  var isDone = false

  function spawn()
    printTimed("|cffceac15>> The wave begins!", 10.)
    NEXT_WAVE.play()
    nextStep()
      
  function nextStep()
    if steps.isEmpty()
      isDone = true
    else
      steps.dequeue().execute() -> 
        nextStep()
      

  function finish()
    printTimed("|cff1f9913>> Wave cleared!", 10.)
    WAVE_FINISHED.play()
    //+ TODO - temporary decision - One active player gets 50% additional gold and exp.
    //  And for each additional player additional bounty decreased by 1/7.
    //  So at 8 players there won't be any additional bounty, just wave based values.
    let additionalExpBounty = (expBounty * 0.5 * (8-pData.size())/7).round()
    let additionalGoldBounty = (goldBounty * 0.5 * (8-pData.size())/7).round()
    //-

    pData.forEach() (player p, PlayerData playerData) -> 
      print("pdata")
      let heroUnit = playerData.getHero().actor
      print("heroUnit: " + heroUnit.getName())
      p.addGold(goldBounty + additionalGoldBounty)
      playerData.getHero().addXp(expBounty + additionalExpBounty, true)
    
      if not heroUnit.isAlive()
        heroUnit.revive(HERO_PICK_RECT.randomPoint(), true)
        heroUnit.setHP(heroUnit.getMaxHP() * 0.5)
        heroUnit.setMana(heroUnit.getMaxMana() * 0.2)
      else 
        AFTER_WAVE_RESTORATION_SOUND.play(1, 30)
        flashEffect(Abilities.replenishHealthCasterOverhead, heroUnit.getPos())
        heroUnit.setHP(heroUnit.getMaxHP())
        heroUnit.setMana(heroUnit.getMaxMana())
    